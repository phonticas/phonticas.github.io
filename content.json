{"meta":{"title":"protons-z","subtitle":null,"description":"proton's blog","author":"proton's blog","url":""},"pages":[{"title":"comment","date":"2020-04-01T06:05:11.000Z","updated":"2020-11-24T08:30:45.102Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"有什么不完善的地方欢迎指出","keywords":"留言板"},{"title":"关于","date":"2020-11-24T08:30:45.101Z","updated":"2020-11-24T08:30:45.101Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"念两句诗 「关于我」 &emsp;&emsp;&emsp; 坐标 JLCC&emsp;&emsp;&emsp; 一名 OIER&emsp;&emsp;&emsp;几乎啥也不会，考试全靠运气！&emsp;&emsp;&emsp; 正处于中二病早期（逃（ &emsp;&emsp;&emsp; 更多关于我 &emsp;&emsp;&emsp; 哎，我太颓了。。 「关于博客」 &emsp;&emsp;&emsp; 开局一baidu/Google，装备全靠剽。 &emsp;&emsp;&emsp; 萌新，以前js,css啥也没接触过，就是剽。 白嫖即正义！ &emsp;&emsp;&emsp;最开始实在 Gridea + Github Pages 搭建过博客,但主题太少，有的还不支持$\\LaTeX$，能自定义的很少。&emsp;&emsp;&emsp;然后就放弃了。&emsp;&emsp;&emsp;之后尝试过博客园，但是感觉都是CSS 也没啥意思，也放弃了。博客园&emsp;&emsp;&emsp;最后使用了 Hexo + Github Pages 感觉使用熟练后发现功能好多，现在依旧使用。&emsp;&emsp;&emsp;Github Pages中间崩过一次，然后再cloudflare上曾使用过自己的域名。但特别慢。&emsp;&emsp;&emsp;然后就没有使用自己的域名了，反观github.io突然速度上升好多！！！&emsp;&emsp;&emsp;是不是国家发福利了？&emsp;&emsp;&emsp;果断换回来。&emsp;&emsp;&emsp;晚上速度可能会慢一点。也可以理解呀。&emsp;&emsp;&emsp;放上我看过的博客搭建的资料（这是不是不算白嫖啦）&emsp;&emsp;&emsp;主题 Sakura&emsp;&emsp;&emsp; https://ctz45562.github.io/2019/06/04/blog%E3%81%AE%E6%90%AD%E5%BB%BA%E4%B9%8Bsakura/&emsp;&emsp;&emsp; https://yremp.club/2019/05/26/teach/&emsp;&emsp;&emsp; https://yremp.live/sakura-js/"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-11-24T08:30:45.103Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-11-24T08:30:45.103Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友链"},{"title":"tags","date":"2020-04-01T06:05:11.000Z","updated":"2020-11-24T08:30:45.103Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":"","keywords":"标签"},{"title":"Root","date":"2020-03-04T03:20:11.000Z","updated":"2020-11-24T08:30:45.103Z","comments":true,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"测试$markdown$ \\left[ \\begin{matrix} 1 &amp; 2 &amp; \\cdots &amp; 4 \\\\ 7 &amp; 6 &amp; \\cdots &amp; 5 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 8 &amp; 9 &amp; \\cdots &amp; 0 \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} 1 & 2 & \\cdots & 4 \\\\ 7 & 6 & \\cdots & 5 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 8 & 9 & \\cdots & 0 \\\\ \\end{matrix} \\right]这个文章是用来测试的 测试表情测试 $fancybox$ 测试 $icon$ 测试 $copy code$ for(int i=1;i&lt;=100;i++) puts(&quot;君指先跃动の光は、私の一生不変百の信仰に、唯私の超电磁炮永生き！&quot;); 测试 $Link$ 蒟蒻’s blog \\exists","keywords":null},{"title":"关于我","date":"2020-11-24T08:30:45.101Z","updated":"2020-11-24T08:30:45.101Z","comments":true,"path":"about/me/index.html","permalink":"/about/me/index.html","excerpt":"","text":"我为什么会走上OI的道路？$Pre$我，来自吉林省，长春市，东师附中。 加入$OI$已经两年了! 说到为什么会选择$OI$，对于我还真是一个巧合。 那年，我还是一个整天都在想着打游戏的傻孩子时； 那年，我还是和同学打氪金游戏总输时； 那年，我还是想破解邻居家$wifi$时； 对于计算机的梦，在我幼小的心灵中，生根发芽了。 $Mid$我，来自吉林省，长春市，东师附中。 那年，我还不是这个身份； 那年，我在数学竞赛失利； 那年，我有幸被$wxg$老师遇见了； 那年，或许我并不会学习$OI$，而只是学学基本编程； 但幸运的是，在那年，那机房，我被深深吸引，从而走上了$OI$的道路。 $why?$ 那要从一个破解扫雷的程序说起 $Game$我，来自吉林省，长春市，东师附中。热爱游戏。 我，真的时被游戏骗到$OI$的。 那年，我热爱游戏，更爱玩破解游戏； 那年，我热爱游戏，却不氪金； 那年，虽然我热爱游戏，但还是被吊打； 那年，我热爱游戏，在一次$OI$体验课时， 老师运行了一个破解扫雷的程序，我看到他 那年，我热爱游戏，认为$OI$就是学怎么破解游戏； 那年，我下定决心要变强！ 由于游戏，那年，$OI$的梦启航了! $Progress$我，来自吉林省，长春市，东师附中。对计算机一窍不通。 那年，初学编程； 那年，我在那之前从未研究过计算机； 那年，我连$exe$文件是什么都不知道； 那年，我...我... 那年，我真正认识到自己想要变强，就一定要付出更多！ 那年，我，暂时，认输了... 即将到初中，那年春天，夏天，我准备了很多，为了新到的学校！ 如果说，那年是$OI$梦想的启航；那么这次，真正迎风启航了！ $Failure$ & $Restart$我，来自吉林省，长春市，东师附中。尝过失败，也终会重启。 $fail$那年，我来到初中。 那年，那年过的很快，很匆； 那年，我在彷徨中又彷徨了一年； 彷徨，彷徨，彷徨到了初二； 初二，初二，初二依旧彷徨。 我不甘心，不甘再浪费了初一； 不甘，回忆初一就只能想到那灰色的走廊； 当别人超越，不甘就这么失败了。 曾经那熙熙攘攘的灰色走廊里，人流涌动； 如今，曲终人散，人几近走光，依旧怀念那灰色走廊的似乎只有我一个人了； 只有我一个人依旧呆呆地守着那安逸的的灰色回忆。 $restart$时间到了0202这个在家里就能见证历史的时代。 我更加相信人的行动是可以改变历史的命运。 所以过去已成历史，我们的行动会改变新的历史。 加油China,加油还在依旧努力的人们，加油所有的OIer们，加油一个在CC的普通中学的kc!"}],"posts":[{"title":"python3一些常用操作","slug":"python3","date":"2020-08-23T13:59:11.000Z","updated":"2020-11-24T08:30:45.098Z","comments":true,"path":"2020/08/23/python3/","link":"","permalink":"/2020/08/23/python3/","excerpt":"","text":"我用的是python3.8.1本文大概记录一下python最基础的（和OI）有关的一些操作。 最重要的！！！python不同于c++/Javapython通过缩进来确定代码的逻辑不同于c++/c/Java使用{ }来确定代码逻辑所以想表达类似 if(opt){ puts(&quot;xxxx&quot;); } 在python中要 if opt : print(xxxxx) 同时python是支持交互形式的所以要是想像写c++这么写建议装一个vscode或者其他支持python的编译器以获最佳体验 python 读入字符串s=input() python字符串转整形s=input() print(int(s)) python for循环for i in range(n): print(i) #从0到n-1 for i in range(l,r): print(i) #从l到r-1 for i in range(a,b,c): print(i) #从a到b-1步长是c python 函数def oxo(a,b,c): print(a+b+c) python 数组（字典）dic={} dic[&#39;sss&#39;]=&#39;esdp&#39; dic[1]=&#39;esd&#39; dic[-1]=333 print(dic[1]) print(dic[-1]) print(dic[&#39;sss&#39;]) python 数组（列表）g=[] #列表下标从0开始 g.append(1) #再列表最后插入1类似c++的push_back g.append(&#39;ssss&#39;) g.append(&#39;qbs&#39;) g.append(&#39;msannu&#39;) g[1]=&#39;-wes&#39; #修改&#39;1&#39;的位置的值 del g[1] #删除&#39;1&#39;这个位置 print(g) python 文件写入#新建s.in并且写入 file=open(&#39;s.in&#39;,&#39;w&#39;) file.write(&#39;xywcjwyy&#39;) python 文件读入#读入s.in文件全部读完 file=open(&#39;s.in&#39;) print(file.read()) python 随机数import random for i in range(10): print(random.uniform(1,20)) #随机浮点 for i in range(10): print(random.randint(1,20)) #随机整型 g=[1,3,2,4,2,1] random.shuffle(g) print(g) #random shuffle随机排序 l=[1,&#39;ss&#39;,&#39;sdd&#39;,&#39;dd&#39;,-1,1e9] pec=random.choice(l) print(pec) #有限集合内随机选取","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"python3","slug":"python3","permalink":"/tags/python3/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"二分图/分治","slug":"二分图-分治","date":"2020-08-22T15:59:11.000Z","updated":"2020-11-24T08:30:45.099Z","comments":true,"path":"2020/08/22/二分图-分治/","link":"","permalink":"/2020/08/22/二分图-分治/","excerpt":"","text":"二分图/分治我们按时间建一棵线段树，线段树每个叶子节点需要能表示出该时刻有边的情况。 就比如说我要修改红色的那个区间。只需要修改 红x 的结点，在访问的时候只要把从叶子节点到根节点的路径上的加边情况加一起就可以了。那问题在于怎么判断是不是二分图呢？可参考关押罪犯大概就是A不能和B在同一边,B不能和C在同一边,在这种情况下A,C姑且只能在一边。所以也就是B和所有不能和A在同一边的 在同一边。A也同理，和所有不能和B在同一边的 在同一边。 这时怎么去求解每个叶子节点的加边情况呢？可以在线段树上遍历（dfs），然后暴力加边（在并查集内），同时也要撤销一些操作。我们当然不能去写一些什么主席树+并查集来维护可持久化并查集。所以只要用一个按秩合并的并查集即可。按秩合并就是类似，这样：B比A长，所以A要认B做爹。因为这么做才会让这个并查集更平衡，也就是更短（更扁）。如果A,B一样长，那么B的长度因为加了一条边（红边）所以B的长度+1。其他情况B长度不变。而撤销也很简单，就是如果操作是A要认B做爹，撤销就是把A,B长度还原，把A的爹设成自己。这里一定要逆着操作顺序!!! #include&lt;bits/stdc++.h&gt; using namespace std; inline void read(int &amp;x) { char c=getchar();x=0; while(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;) c=getchar(); while(c&lt;=&#39;9&#39;&amp;&amp;c&gt;=&#39;0&#39;) x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); } struct seg { vector&lt;pair&lt;int,int&gt; &gt;a; int l,r; }t[401000]; int fa[201000]; inline void build(int pos,int l,int r) { t[pos].l=l;t[pos].r=r; if(l==r) return ; int mid=l+r&gt;&gt;1; build(pos&lt;&lt;1,l,mid); build(pos&lt;&lt;1|1,mid+1,r); } inline void modify(int pos,int x,int y,pair&lt;int,int&gt; z) { if(x&lt;=t[pos].l&amp;&amp;t[pos].r&lt;=y) { t[pos].a.push_back(z); return ; } int mid=t[pos].l+t[pos].r&gt;&gt;1; if(y&lt;=mid) modify(pos&lt;&lt;1,x,y,z); else if(x&gt;mid) modify(pos&lt;&lt;1|1,x,y,z); else modify(pos&lt;&lt;1,x,y,z),modify(pos&lt;&lt;1|1,x,y,z); } //以上均为线段树 int n,m,T; int x,y,a,b,d[201000]; bool f; inline int getroot(int x) { if(x==fa[x]) return x; return getroot(fa[x]); } stack&lt;pair&lt;int,int&gt; &gt;s; inline void merge(int x,int y) { if(x==y) return ; if(d[x]&gt;d[y]) swap(x,y); s.push(make_pair(x,d[x]==d[y])); fa[x]=y; d[y]+=(d[x]==d[y]); } inline void dfs(int pos) { int sz=s.size(); bool f=0; for(int i=0;i&lt;t[pos].a.size();i++) { int x=t[pos].a[i].first,y=t[pos].a[i].second; int rtx=getroot(x),rty=getroot(y); if(rtx==rty) { f=1; for(int j=t[pos].l;j&lt;=t[pos].r;j++) puts(&quot;No&quot;); break; } merge(rtx,getroot(y+n)); merge(rty,getroot(x+n)); } if(f==0) { if(t[pos].l==t[pos].r) { puts(&quot;Yes&quot;); return ; } dfs(pos&lt;&lt;1); dfs(pos&lt;&lt;1|1); } while(s.size()&gt;sz) { d[fa[s.top().first]]-=s.top().second; fa[s.top().first]=s.top().first; s.pop(); } } int main() { #ifdef _WIN32 freopen(&quot;b4025.in&quot;,&quot;r&quot;,stdin); freopen(&quot;b4025.out&quot;,&quot;w&quot;,stdout); #endif read(n),read(m),read(T); // T++; build(1,1,T); for(int i=1;i&lt;=2*n;i++) fa[i]=i; for(int i=1;i&lt;=m;i++) { read(x),read(y),read(a),read(b); a++; if(a&gt;b) continue; modify(1,a,b,make_pair(x,y)); } dfs(1); }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"分治","slug":"分治","permalink":"/tags/分治/"},{"name":"并查集","slug":"并查集","permalink":"/tags/并查集/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"分治学习笔记","slug":"分治学习笔记","date":"2020-08-22T15:28:11.000Z","updated":"2020-11-24T08:30:45.099Z","comments":true,"path":"2020/08/22/分治学习笔记/","link":"","permalink":"/2020/08/22/分治学习笔记/","excerpt":"","text":"cdq分治待填 按时间分治例题二分图 太晚了要睡觉了，明天再更","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"分治","slug":"分治","permalink":"/tags/分治/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"ZJOI2014力","slug":"ZJOI2014力","date":"2020-08-01T12:20:11.000Z","updated":"2020-11-24T08:30:45.098Z","comments":true,"path":"2020/08/01/ZJOI2014力/","link":"","permalink":"/2020/08/01/ZJOI2014力/","excerpt":"","text":"ZJOI2014 力题目大意 F_j=\\sum_{ij} \\dfrac{q_i q_j}{(i-j)^2}求$E_i=\\dfrac{F_i}{q_i}$ 化简$E_i$ \\begin{aligned} E_j&=\\dfrac{F_j}{q_j}\\\\ &=\\dfrac{1}{q_j}\\sum_{ij} \\dfrac{q_i q_j}{(i-j)^2}\\\\ &=\\sum_{ij} \\dfrac{q_i}{(i-j)^2}\\\\ &=\\sum_{i=1}^{j-1} \\dfrac{q_i}{(i-j)^2} - \\sum _{i=j+1}^{n} \\dfrac{q_i}{(i-j)^2} \\end{aligned}我们根据卷积的定义 C(n)=\\sum _{i=0}^{n}F(i)\\times G(n-i)设 $F(x)=q_x$ , $G(x)=\\dfrac{1}{x^2}$ 原式化简为 $E{j}=\\displaystyle\\sum{i=1}^{j-1}F(i)\\times G(j-i)-\\displaystyle \\sum _{i=j+1}^{n}F(i)\\times G(i-j)$前面那个便是 $F$ 卷 $G$ \\displaystyle \\sum _{i=j+1}^{n}F(i)\\times G(i-j)设$k=i-j$ 原式 $=\\displaystyle \\sum{k=1}^{n-j}F(k+j)G(k)$翻转$F$后得到$h$,$h$ 满足 $h(i)=F(n-i)$ , 同时 $F(i)=h(n-i)$原式 $=\\displaystyle \\sum{k=1}^{n-j}h(n-j-k)G(k)$设 $t=n-j$原式 $=\\displaystyle \\sum_{k=1}^{t}h(t-k)G(k)$故 后面的是$h$ 卷 $G$所以我们将前后分开算，也就是先把$F$ $G$ $h$ fft成点值表示然后分别计算卷积后插值，就可以了！ #include&lt;bits/stdc++.h&gt; using namespace std; const int N=400000; struct Complex { double x,y; }f[N],g[N],h[N]; Complex operator + (Complex a,Complex b) { Complex c; c.x=a.x+b.x; c.y=a.y+b.y; return c; } Complex operator - (Complex a,Complex b) { Complex c; c.x=a.x-b.x; c.y=a.y-b.y; return c; } Complex operator * (Complex a,Complex b) { Complex c; c.x=a.x*b.x-a.y*b.y; c.y=a.x*b.y+a.y*b.x; return c; } const double pie=acos(-1); int rev[N]; inline void fft(Complex *a,int lim,int flag) { for(int i=1;i&lt;lim;i++) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int mid=1;mid&lt;lim;mid=(mid&lt;&lt;1)) { Complex wn; wn.x=cos(pie/double(mid)); wn.y=1.0*flag*sin(pie/double(mid)); for(int j=0;j&lt;lim;j+=(mid&lt;&lt;1)) { Complex w; w.x=1.0,w.y=0; for(int k=0;k&lt;mid;k++,w=w*wn) { Complex x=a[k+j],y=w*a[k+j+mid]; a[k+j]=x+y; a[k+j+mid]=x-y; } } } if(flag==-1) for(int i=0;i&lt;lim;i++) a[i].x/=double(lim); } int n; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;f[i].x); for(int i=0;i&lt;=n;i++) g[i].x=f[n-i].x; for(int i=1;i&lt;=n;i++) h[i].x=(1.0/(1.0*double(i)))/(double(i)); int lim=1,len=0; while(lim&lt;=2*(n)) lim&lt;&lt;=1,len++; for(int i=1;i&lt;lim;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1)); fft(f,lim,1); fft(g,lim,1); fft(h,lim,1); for(int i=0;i&lt;lim;i++) f[i]=f[i]*h[i]; for(int i=0;i&lt;lim;i++) g[i]=g[i]*h[i]; fft(f,lim,-1); fft(g,lim,-1); for(int i=1;i&lt;=n;i++) printf(&quot;%.6lf\\n&quot;,f[i].x-g[n-i].x); #ifdef _WIN32 system(&quot;pause&quot;); #endif }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"/tags/多项式/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"link-cut-tree","slug":"link-cut tree","date":"2020-07-22T15:43:11.000Z","updated":"2020-11-24T08:30:45.098Z","comments":true,"path":"2020/07/22/link-cut tree/","link":"","permalink":"/2020/07/22/link-cut tree/","excerpt":"","text":"link-cut tree 顾名思义 可以支持树上的动态操作 而其主要是如何通过splay来表示原树 lct 亦称实链剖分我们使用一颗splay来维护一条实链,splay里点的权便是该点在原树中的深度 直入主题，怎么通过splay的变化来反映原树的变化 操作 重中之重 access(x)操作，即打通一条均是实链的从x到原树的根的路径。因为是打通根到x的路径，所以x一定在打通后的实链的链底。那么我们想一下由于是实链的底，深度一定最大，所以splay(x)到根后，x深度一定比链上所有节点深度大。所以现在splay上x的所有儿子都在其左子树上（左子树&lt;根&lt;右子树）。而此时现在splay上x的根边是在原树上现在这条实链的链顶的父亲。因为lct中spaly上认父不认子，所以我们可以直接找到链顶的父亲f，考虑它(f)也是这个实链的链底，所以我们也对f进行类似刚刚对x的操作。先将f,splay到根，然后f左子树只剩下它原先的实儿子和其(实儿子)下子。此时我们便把f右儿子直接换成x,由于虚边认父不认子，原先的实儿子变虚，x变实儿子。继续进行该操作直到到达根节点。 inline void access(int x) { for(int y=0;x;y=x,x=fa[x]) { splay(x); // 把x旋到根 t[x].son[1]=y; //更改右儿子（右子树） pushup(x); // 更新结点 } } makeroot(x) 操作，将x换成原树的根。我们考虑怎么做，首先，对x先打通一条到根的路径（access(x)）。此时因为x是这个实链的底，深度最大，所以把此时的x,splay到根，那么，x的右子树便是空的。假如我们把x提到原树的根，那么显然对于原先结点 $k$,$dep_k=dep_x-dep_k$ 。我们可以看出这个把符号 &gt; 转换成 &lt; ，也就是把splay的左右子树反转。在文艺平衡树中我们通过打标记和pushdown一系列操作进行区间翻转。 inline void makeroot(int x) { access(x); spaly(x); t[x].rev=1; } findroot(x) 操作，找出x原树的根（lct维护的可以是森林）。怎么做？因为根的dep最小，所以我们类似makeroot(x)中先access(x),再splay(x)使得x为splay根。然后一直找左儿子（左儿子&lt;根&lt;右儿子） ，最后的既为根。 inline int findroot(int x) { access(x);splay(x); while(t[x].son[0]) x=t[x].son[0]; return x; } link(x,y) 操作在原树上连接(x,y)。怎么做？我们考虑(x,y)原先一定不联通（因为lct只能维护树）。所以现在我们要先判断 $[findroot(x)=findroot(y)]$。其次，我们先把x换到原树那个根，然后因为是根所以他没有爸爸。我们考虑加一条虚边从 $x-&gt;y$因为是虚边，y的形态不改变，而x是原树的根把他的爸爸改成y对他的子树无影响。所以就可以直接连虚边，来进行link操作。inline void link(int x,int y) { makeroot(x); fa[x]=y; } split(x,y) 操作在原树上提取从(x-&gt;y) 这条链。我们可以先把x换成根（makeroot(x)）,然后直接打通y到根的路径（access(y)），然后只要把y splay到根就可以直接查询这条链的信息！inline void split(int x,int y) { makeroot(x); access(y); splay(y); } cut(x,y) 操作在原树上断掉$(x-&gt;y)$ 这条边。我们先提取出来(x,y)这条边(split(x,y))，然后因为(x,y)是相连的。$dep_x=dep_y-1$显然，假如y是根，x就是y的左儿子，我们自然可以直接把y的左儿子改成虚的，也就是不要了，x的父亲也不认。（这并不是虚边认父不认子）inline void cut(int x,int y) { split(x,y); if(t[y].son[0]==x) t[y].son[0]=0; }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"link-cut-tree","slug":"link-cut-tree","permalink":"/tags/link-cut-tree/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"莫比乌斯反演","slug":"莫比乌斯反演","date":"2020-06-23T12:17:11.000Z","updated":"2020-11-24T08:42:07.905Z","comments":true,"path":"2020/06/23/莫比乌斯反演/","link":"","permalink":"/2020/06/23/莫比乌斯反演/","excerpt":"","text":"数论函数的积性若 $f(x)$ 满足 $\\forall x_1,x_2,(x_1,x_2)=1$ 都有 $f(x_1\\times x_2)=f(x_1)\\times f(x_2)$ 那么称f(x)为积性函数Eg. $\\varphi(n)$ 表示小于n且与n互质的数的个数 $\\mu(n)$ 莫比乌斯函数.设 $n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_t^{\\alpha_t}$若 $\\exists \\alpha_k&gt;1$ 则 $\\mu(n)=0$否则 $\\mu(n)=(-1)^t$ $\\sigma(n)$ 表示n的约数和 $id(n)=n$ $1(n)=1$ $\\varepsilon(n)$若 $n=1$ 时 $\\varepsilon(n)=1$否则 $\\varepsilon(n)=0$ 迪利克雷卷积定义 $h=fg$ , 其中``运算为迪利克雷卷积。则 h(d)=\\sum _{t\\mid d} f(t)\\times g(\\frac{d}{t})特别注意，若 $f$ , $g$ 均为积性函数，那么 $h$ 也为积性函数。 证明如下: \\begin{aligned} h(d)&=\\sum _{t\\mid d} f(t)\\times g(\\frac{d}{t})\\\\ h(d_1d_2) &= \\sum _{t\\mid d_1d_2} f(t)\\times g(\\frac{d_1d_2}{t})\\\\ &=\\sum _{t_1\\mid d_1,t_2\\mid d_2} f(t_1t_2)\\times g(\\frac{d_1d_2}{t_1t_2})\\\\ &=\\sum _{t_1\\mid d_1,t_2\\mid d_2} f(t_2)\\times g(\\frac{d_1}{t_1})g(\\frac{d_2}{t_2})\\\\ &=\\sum _{t_1\\mid d_1}\\sum_{t_2\\mid d_2}f(t_1)\\times g(\\frac{d_1}{t_1}) \\times f(t_2)\\times g(\\frac{d_2}{t_2})\\\\ &=\\sum _{t_1\\mid d_1}f(t_1)\\times g(\\frac{d_1}{t_1})\\sum_{t_2\\mid d_2} f(t_2)\\times g(\\frac{d_2}{t_2})\\\\ &=h(d_1)h(d_2) \\end{aligned}迪利克雷卷积的性质\\varphi * 1 = id\\mu * id = \\varphi\\mu * 1 =\\varepsilonid *1 = \\sigma证明其一 \\varphi * 1 = id证明如下: \\begin{aligned} h(d)&=\\sum _{t\\mid d}\\varphi(t)=d\\\\ &=\\sum_{t\\mid d}t\\prod(1-\\frac{1}{p_i})\\\\ &=\\sum_{t\\mid d}\\prod p_i^k(1-\\frac{1}{p_i})\\\\ d&=\\prod p_i^{\\alpha_{i}}\\\\ 现在类似&考虑d的因数，若有因子p_i\\\\ 那提出因式&\\ \\ \\ \\ \\ (p_i+p_i^{2}+p_i^3+\\cdots +p_i^{\\alpha_{i}})\\\\ &=p_i\\times\\frac{p_i^{\\alpha_{i}}-1}{p_i-1}\\\\ h(d)中有&\\prod(1-\\frac{1}{p_i})=\\prod(\\frac{p_i-1}{p_i})\\\\ \\end{aligned}综合起来,不难发现h(d)可以通过枚举因数来求枚举因数 $a_1-a_k$","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"莫反","slug":"莫反","permalink":"/tags/莫反/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"JLOI2020","slug":"JLOI游记","date":"2020-06-21T11:43:11.000Z","updated":"2020-11-24T08:30:45.097Z","comments":true,"path":"2020/06/21/JLOI游记/","link":"","permalink":"/2020/06/21/JLOI游记/","excerpt":"","text":"期待已久的省选即将到来。在家里待了快半年，我也感到有点空虚。几次NOI Online 感觉题目不是很难 (尽管只有最后一次进了25%)似乎感到“我又行了” 2020.6.19没看什么知识点，感觉很紧张（因为省选知识店还没学完）尽管很早睡但没休息好。 2020.6.20Day1在我的学校考试了！ t1感觉不是很难，感觉随便90，但是。。。第一眼觉得的 $O(q\\log n)$ , 写成 $O(q\\log^2 n)$.而 $O(q\\log^2 n)$ 维护的好长，写了200行左右，废了快 $2h$ ,过不了大样例!!!!!30分暴力先搁置一会儿吧。 t2觉得很像二项式反演，推了推没整出来。。。就写了 $O(n^2)$ 的10分+$O(\\log n)$ 的部分分30分…10min打完部分分，自闭了。。。 t3啥，暴力都打不出来?我只会暴力 $O(5^n*C_{10}^4)$ 的，然而一分没有。更自闭了。此时还剩大约1.5h re:t1继续改改刚才写的，然后小样例都过不去了，没保存。。。。写部分分，30分也写了100多行，然后大样例再一次没过。。彻底自闭。。。。 总结后来发现其实t1随便拿60,90而我t2竟然忘了freopen out了。。day1爆零。学长啥的人均150-200+南方的好像一堆300………还是自己菜……(没发现t3是网络流，t2是斯特林) 2020.6.21也就是今天。。day1爆零，day2没啥心情了。。 t1不会。。直接30分暴力。。。10min。。。。m=21,m=22,m=23各弄一个点是想干什么？？？（显然卡常状压。。） t2不会。。直接20分暴力。。。10min。。。。（梅开二度）两个20%数据发现很正解几乎很像了。想不出来而40%数据和100%数据很接近了放弃。。。。。 t3生成树？一眼就看出来矩阵树定理。But怎么做???（这个zz没看出来gcd是莫反。。）也是30分暴力随便打了。。。此时还剩下快3h检查了代码，文件输入输出，没问题。然后就在考场上颓了。。。。。。。。。。。 总结day2知识店都能猜出（t2线段树合并）但是没有思路。。学长们也人均切一道题。。。。就是练的题少！！！！ 感想省选使我看到了自己实际上还有很大不足（暴力打挂+知识点不会）也认清了和同学之间的差距 (I:70-,P:300+,S:500+-)不能再颓废了！！！！！（对，你还要补作业呢！！！） 这里写的或许也就是想给未来的自己看的，记得刚学OI时也经历了一段这样的时期（语法学了快半年。。。）不知道1年，2年后的我是什么的样子，退没退役？有没有政策？也不知道那时候还会怎么看现在的我，这篇文章。扯远了最近学了岳阳楼记（正在对译。。。）我还是很欣赏范仲淹的“不以物喜，不以己悲”，“宠辱偕忘”的也希望我（以及看到这里的各位）在接下来的竞赛道路上依旧“不以物喜，不以己悲”，把竞赛当成真心的乐趣吧！ 2020.6.21 Sunday 19:43","categories":[{"name":"游记","slug":"游记","permalink":"/categories/游记/"}],"tags":[],"keywords":[{"name":"游记","slug":"游记","permalink":"/categories/游记/"}]},{"title":"取石子游戏","slug":"取石子游戏","date":"2020-04-28T15:20:11.000Z","updated":"2020-11-24T08:30:45.099Z","comments":true,"path":"2020/04/28/取石子游戏/","link":"","permalink":"/2020/04/28/取石子游戏/","excerpt":"","text":"题目链接 大意给你一堆石子，每次只能取最左或最右的石子，问是否有必胜策略。 题解这道题我们并不能通过Nim/SG的思想做出。大神们说可以区间dp。那我们可以设 $L{i,j}$ 表示若在i的左面放 $L{i,j}$ 则先手必输。类似的我们可以设 $R{i,j}$ 表示若在j的右面放 $R{i,j}$ 则先手必输。 step1$L{i,j}$,$R{i,j}$ 有且仅有一种答案。 证明唯一性:首先假设存在 $L{i,j}$ 设k可满足先手必输的性质。若 $k&gt;L{i,j}$,那么假如我把k堆取成 $L{i,j}$ 那么这其实是存在必胜状态，不成立；若 $k&gt;L{i,j}$,那么假如我把 $L{i,j}$ 堆取成k 那么$L{i,j}$ 存在必胜状态，不成立.综上 有唯一性。证明存在性:假如不存在这个$L{i,j}$ 使得为必输情况，那没无论怎么取$L{i,j}$均为必胜。假如在左面取了k个，那么此时是一个必胜态，所以不能在左面取。只能在右面取，那么这还是对于任意左面的多少都是必败态，和上述类似，这种是肯定不行的。故，不存在 “不存在 $L_{i,j}$”的情况。R可以理解为把L整个数列翻转。 有了存在且唯一性，我们就可以直接找特例的答案； step2转移 $L{i,j}$为了方便记 $l=L{i,j-1}$,$r=R{i,j-1},x=a_j$首先，我们考虑 $L{i,i}=ai$因为$a{i-1}=a_{i}$ 后手可以模仿先手，这样后手一定必胜。 假如 $r=x$ 那么：$L{i,j}=0$因为，我们定义$R{i,j-1}$ 为在$j-1$ 的右面加上数，所以就是在 j 加上数，而有恰巧为 $a_j$，所以说明本身这个状态为必败。 假如 $x&lt;l,x&lt;r$ 那么：$L_{i,j}=x$因为这样我们构造了最左和最右相同的一个状态。此时我们不管先手怎么取我们都模仿他。最后肯定是先手取完一堆，然后我们都会剩一堆，此时 $x&lt;l,x&lt;r$ ，所以一定是先手必胜。 假如 $x&gt;l,x&gt;r$ 那么：$L_{i,j}=x$证明类似。 假如 $l&lt;x&lt;r$$L_{i,j}=x+1$因为我们依旧可以学对面怎么取，假如剩下x，我们依旧可以取成两堆相同的。这就和上两种一样了。 假如 $r&lt;x&lt;l$$L_{i,j}=x-1$同理这样就可以区间dp了。","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"/tags/博弈论/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"博弈论","slug":"博弈论","date":"2020-04-20T15:20:11.000Z","updated":"2020-11-24T08:30:45.099Z","comments":true,"path":"2020/04/20/博弈论/","link":"","permalink":"/2020/04/20/博弈论/","excerpt":"","text":"我发现自己挖坑的速度堪比挖坟速度。又开新坑了。。。。 Nim 博弈Nim游戏是公平组合游戏。（大意就是在任意一时间点，互换游戏双方对其游戏本身没有影响）。 两名选手。 两名选手轮流行动，每一次行动可以在有限合法操作集合中选择一个。 游戏的任何一种可能的局面(position)，合法操作集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它因素；局面的改变称为“移动”(move)。 如果轮到某名选手移动，且此时无法进行移动，则这名选手负。 而局面共分为两种： P-position 先手必输。 N-position 先手必胜。 取石子$A_i$ 表示第 $i$ 堆的石子数。假如一个局面为P-position $\\Leftrightarrow$ $A_1\\ xor\\ A_2\\ xor \\ \\cdots \\ \\ xor\\ A_n=0$ 证明,我们考虑数学归纳 假如$\\forall i\\in [1,n] A_i=0$ , 一定是P-position 若不是，则设$x=A_1\\ xor\\ A_2\\ xor \\ \\cdots \\ \\ xor\\ A_n (x\\not ={0})$那么此时，设 $x$ 的二进制下最高位为第 $k$ 位。由于异或的本身性质，$\\exists i\\in [1,n]$ 使得$A_i$ 的第 $k$ 位为1。有结论:$A_i\\ \\ xor\\ k&lt;A_i$下面给出证明：由于 $k$ 是 x的最高位，所以 $k$ 位以上的不用管，只考虑 $k$ 位以下的原先的 $A_i$ 的第 $k$ 位为1，异或后为 0 显然小了。所以我们可以把 $A_i$ 这堆取成 $A_i\\ \\ xor\\ x$。此时 $A_1\\ xor\\ A_2\\ xor \\ \\cdots \\ (A_i\\ \\ xor\\ x)\\ \\cdots\\ \\ xor\\ A_n=x\\ \\ xor\\ x=0$所以根据归纳假设，移动后的局面为 P-position，故此时为 N-position 特别的，若 $x=0$ 那么我们无论如何也找不出一个 $A_i$ 使的，其改变后 $A_1\\ xor\\ A_2\\ xor \\ \\cdots \\ (A_i’)\\ \\cdots\\ \\ xor\\ A_n=0$充分性，必要性都证明完了。先写到这吧。 SG函数SG函数用来解决一些复杂的Nim问题我们先定义从状态x可以到达的状态y为x的一个后继然后 SG(x)=mex{SG(y)|y是x的后继}mex是什么？$mex{a}$ (a是一个集合) 表示为最小的非负整数x不属于a。Eg:mex{0,3,5}=1,mex{0,1,2,3,4}=5;SG函数代表什么呢？如果SG(x)=0表示必输,其余的即为必胜 所以为什么现在的SG函数可以解决Nim问题,也就是P-position,N-position局面我们在分析N position,P position 局面的本质：若为空集,则必为P position存在 可以到达的状态必为P position,那他一定是N position对于任意可到达的状态均为N position,那他一定是P position 那么我们考虑SG(x)的本质:SG(x)=mex{a},若a为空集则SG(x)=0若SG(x)$\\not ={0}$ ,则 $\\exists SG(y)=0$若SG(x)=0,则 $\\forall SG(y)\\not ={0}$ 是不是发现了SG 函数其实对应了N/P position 局面 这种对应其实也说明了，可以像N/P position 局面一样拆成若干子问题，然后求异或和。 总结，我们在做Nim的题时，重要的不是求出SG而是找到x-&gt;y这种的后继关系。因为这种后继关系本质是构造了一个DAG，而DAG我们可以dp，而dp才是重要的！！","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"/tags/博弈论/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"拉格朗日插值·模板","slug":"拉格朗日插值","date":"2020-04-19T15:20:11.000Z","updated":"2020-11-24T08:30:45.100Z","comments":true,"path":"2020/04/19/拉格朗日插值/","link":"","permalink":"/2020/04/19/拉格朗日插值/","excerpt":"","text":"首先我们考虑我们有 $n$ 个点值表达式。 \\begin{Bmatrix}(x_1,y_1),(x_1,y_1)\\cdots(x_n,y_n)\\end{Bmatrix}我们想构造 $\\forall i\\in [0,n]\\ \\ \\ F(x_i)=y_i$。 F(x)=\\sum _{i=0}^{n}y_i\\times f_i(x)$f_i(x)$满足 $\\forall j\\not ={i} f_i(x_j)=0$,$f_i(x_i)=1$。所以构造多项式。 f_i(x)=\\prod_{j=0,j\\not ={i}}^{n}\\frac{x-x_j}{x_i-x_j}=\\frac{x-x_0}{x_i-x_0}\\cdots\\frac{x-x_{i-1}}{x_i-x_{i-1}}\\frac{x-x_{i+1}}{x_i-x_{i+1}}\\cdots \\frac{x-x_n}{x_i-x_n}分析： 当 $x=xi$ 时 $f_i(x_i)=\\displaystyle\\prod{j=0,j\\not ={i}}^{n}\\frac{x_i-x_j}{x_i-x_j}=\\prod 1=1$ 当 $x\\not =x_i$ 时，设$x=x_k$ 则分子为 $(x_k-x_1)\\cdots(x_k-x_k)\\cdots (x_k-x_n)=0$ ,$\\ \\ f_i(x_k)=0$ ok!就是你啦。 F(x)=\\sum _{i=0}^{n}y_i\\times \\prod_{j=0,j\\not ={i}}^{n}\\frac{x-x_j}{x_i-x_j}#include&lt;bits/stdc++.h&gt; #include&lt;cstdlib&gt; using namespace std; #define int long long inline void read(int &amp;x) { char c=getchar();x=0;int f=1; while(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;) {if(c==&#39;-&#39;) f=-1;c=getchar();} while(c&lt;=&#39;9&#39;&amp;&amp;c&gt;=&#39;0&#39;) x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); x=x*f; } inline int qpow(int a,int b,int p) { int k=1; while(b) { if(b&amp;1) k=k*a%p; a=a*a%p,b=b&gt;&gt;1; } return k; } const int N=1e4,p=998244353; inline int inv(int x){return qpow(x,p-2,p);} int n,k; int x[N],y[N],ans,chushu=1; signed main() { read(n),read(k); for(int i=1;i&lt;=n;i++) read(x[i]),read(y[i]); for(int i=1;i&lt;=n;i++) { int res=1; for(int j=1;j&lt;=n;j++) { if(i==j) continue; res=res*(k-x[j])%p*inv(x[i]-x[j])%p; } ans=ans+res*y[i]%p; } printf(&quot;%lld&quot;,ans%p); }","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"/tags/多项式/"},{"name":"拉格朗日插值","slug":"拉格朗日插值","permalink":"/tags/拉格朗日插值/"},{"name":"组合数学","slug":"组合数学","permalink":"/tags/组合数学/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"多项式全家桶","slug":"多项式全家桶","date":"2020-04-12T15:20:11.000Z","updated":"2020-11-24T08:30:45.099Z","comments":true,"path":"2020/04/12/多项式全家桶/","link":"","permalink":"/2020/04/12/多项式全家桶/","excerpt":"","text":"多项式乘法逆链接 先说几个简单性质： $f\\equiv g\\pmod {x^n}$ $\\Rightarrow$ $\\forall i\\in [0,n], f\\equiv g\\pmod {x^i}$。 $f\\equiv g\\pmod {x^n}$ $\\Rightarrow$ $f^k\\equiv g^k\\pmod {x^{kn}}$。 开始操作。 f\\times g\\equiv 1\\pmod {x^{\\lceil\\frac{n}{2}\\rceil}}f\\times h\\equiv 1\\pmod {x^n}\\Leftrightarrow f\\times h\\equiv 1\\pmod {x^{\\lceil\\frac{n}{2}\\rceil}}f\\times g-f\\times h\\equiv 0 \\pmod {x^{\\lceil\\frac{n}{2}\\rceil}}g-h\\equiv 0 \\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}(g-h)^2\\equiv 0\\pmod{x^{2\\times\\lceil\\frac{n}{2}\\rceil}}\\Leftrightarrow(g-h)^2\\equiv 0\\pmod{x^n}g^2-2g h+h^2\\equiv 0 \\pmod {x^n}左右两边乘上 $f$ g^2f-2g(h\\times f)+h\\times(h\\times f)\\equiv 0 \\pmod{x^n}h\\equiv 2g-g^2f多项式ln函数多项式ln函数首先$B\\equiv \\ln A \\pmod {x^n}$我们两边同时取导 $B^{-1} \\equiv \\ln^{-1} A\\pmod {x^n}$根据小学二年级的知识: B' \\equiv \\frac{A'}{A}\\pmod {x^n}B'=A' A^{-1}\\pmod {x^n}根据 f(x)=\\sum _{i=0}^{n}a_ix^if'(x)=\\sum_{i=0}^{n-1}(i+1)\\times a_{i+1}\\times x^i我们很容易通过 $A$ 得出 $A’$ ;也很容易根据 $A’$ 得出 $A$。所以本题可以使用多项式求逆后 $NTT$ 一次切了。","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"/tags/多项式/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"耻辱柱","slug":"耻辱柱","date":"2020-04-11T16:20:10.000Z","updated":"2020-11-24T08:30:45.100Z","comments":true,"path":"2020/04/12/耻辱柱/","link":"","permalink":"/2020/04/12/耻辱柱/","excerpt":"","text":"总结犯过的 $nc$ 错误，不定期更新。 for 循环要先赋值，在 $++$eg: for (int i = 1;i &lt;= n ; i++ ,k+=v[i]) $dp$ 一定要考虑边界条件，而且 $dp$ 初始值一定要考虑可否直接设为 $0$ 线段树一定要 build 交题时一定不要加 system(&quot;pause&quot;); 数组一定不要开到正好，尽管不知道为什么在$Luogu$ ,和 $Loj$ $AC$ 了。","categories":[],"tags":[],"keywords":[]},{"title":"多项式基础","slug":"多项式基础","date":"2020-04-07T03:20:11.000Z","updated":"2020-11-24T08:30:45.100Z","comments":true,"path":"2020/04/07/多项式基础/","link":"","permalink":"/2020/04/07/多项式基础/","excerpt":"","text":"Q: 什么是 $FFT$?A: $Fast Fourier Transform$ 快速傅里叶变换。 Q: 什么是 $DFT$?A: $Discrete Fourier Transform$ 离散傅里叶变换。 Q: 什么是 $IDFT$?A: $Inverse Discrete Fourier Transform$ 逆·离散傅里叶变换。 Q: 什么是 $NTT$?A: $number theory Transform$ 数论变换。 Q: 什么是 $MTT$?A: 任意模数数论变换。 $FFT$或许有很多人会在这里强调好些引理，但我觉得在推导到那步时能够继续推下去就可以了。 没有必要过分强调。。。 这里将多项式和函数直接对应其中 $f_{x_i}=f(x_i)$该方法用于在$O(n\\log n)$求离散卷积。什么是离散卷积？给出定义，令$y=f\\times g$ y_n=\\sum _{i=0}^{n}f_i\\times g_{n-i}或者这么表示。 y_n=\\sum _{i=- \\infty}^{\\infty}f_i\\times g_{n-i}此时 所构成的多项式${y}$ $=$ $f\\times g$所以譬如我们都知道的十进制竖式乘法就是一种卷积。 引入概念：点值表达式一个多项式可以表达成 $f=\\sum\\limits_{i=0}^{n}a_i\\times x^i$，我们称为其为系数表达式而此时的多项式我们可以理解成一个 $n$ 次的函数而在初中二年级我们就知道，任意 $n+1$ 个点都可以确定一个 $n$ 次的函数。这就是为什么小学一些让你找规律的题其实并没有准确答案。记点集为$\\begin{Bmatrix}(x_0,y_0),(x_1,y_1)\\cdots(x_n,y_n)\\end{Bmatrix}$则$\\forall i\\in[0,n] f(x_i)=y_i$由此我们将系数表达 $\\begin{Bmatrix} a_0,a_1\\cdots a_n\\end{Bmatrix}$ 转换到点值表达 $\\begin{Bmatrix}(x_0,y_0),(x_1,y_1)\\cdots(x_n,y_n)\\end{Bmatrix}$ 的操作称为一次傅里叶变换而从点值重新转回系数表达的插值操作称为一次逆傅里叶变换 点值表达式的好处就在于，当两个点值表达式相乘时： f=\\begin{Bmatrix}(x_0,y_0),(x_1,y_1)\\cdots(x_n,y_n)\\end{Bmatrix}g=\\begin{Bmatrix}(x_0,z_0),(x_1,z_1)\\cdots(x_n,z_n)\\end{Bmatrix}h=f\\times gh=\\begin{Bmatrix}(x_0,y_0),(x_1,y_1)\\cdots(x_n,y_n)\\end{Bmatrix}\\times \\begin{Bmatrix}(x_0,z_0),(x_1,z_1)\\cdots(x_n,z_n)\\end{Bmatrix}\\forall i\\in[0,n],\\ \\ \\ \\ \\ h(x_i)=f(x_i)\\times g(x_i)即$\\ \\ \\ \\ \\ h(x_i)=y_i \\times z_i$,$h$ 的点值表达则为 $\\begin{Bmatrix}(x_0,y_0\\times z_0),(x_1,y_1\\times z_1)\\cdots(x_n,y_n\\times z_n)\\end{Bmatrix}$我们实现了 $O(n)$ 的离散卷积乘法。 但是我们还不知道如何将系数表达式转换为点值表达式一般的我们可以，随便找 $n+1$ 个数然后代入计算。但 $O(2n)$ 的复杂度我们并不允许。我们突然意识到，随便取 $n+1$ 个数是不可能的，这辈子都不可能。这里我们引入概念，$n$ 次单位根的概念：满足 $x^n=1$ 的所有的复数 $x$。 引入复数概念没啥特别的，高中基础吧。 z=a+bi\\ ,\\ \\ (a\\in \\Re,\\ b\\in \\Re,\\ i^2=-1\\ )其中 记 $Re(z) = a$ 表示复数 $z$的实部。记 $Im(z)=b$表示复数 $z$ 的虚部。记 $\\mid z \\mid=\\sqrt{a^2+b^2}$ 表示复数 $z$ 的模长。复数加法法则：实部相加，虚部相加。 Eg:(1+3i)+(2-i)=(3+2i)而加法的实质意义是平行四边形法则。复数乘法法则：相当于拆括号。 Eg:(1+3i)\\times(2+2i)=1\\times 2+3i\\times 2+1\\times 2i+3i\\times 2i=2-6+6i+2i=-4+8i而乘法的实质意义是旋转相似。每一个复数 $z$ 将 $(Re(z),Im(z))$ 在平面上表示出。发现对于任意的一个复数都可以在平面上表示。于是乎，我们将这个平面称为复平面。复数相乘几何意义：模长相乘，副角相加。 引入单位根概念2次单位根：$1$,$-1$。3次单位根：$1$,$\\omega$,$\\omega ^{2}$。4次单位根：$1$,$i$,$-1$,$,-i$。我们发现 $2^k$这种单位根有很好的轴对称以及中心对称性，为了简化问题，下文所说的 $n$ 均默认 $n=2^k,k\\in Z$。我们沿逆时针一圈把单位根标序号，对于第 $i$ 个我们记录为 $\\omega{n}^{i-1}$于是我们生成了 $\\omega{n}^{0},\\omega{n}^{1}\\cdots \\omega{n}^{n-1}$$\\omega{n}^{k}$性质何在？首先我们这么理解为 $\\omega{n}$的 $k$ 次幂由欧拉定理： e^{i\\varTheta}=\\cos {\\varTheta}\\ \\ + i\\sin{\\varTheta}其中 $\\varTheta$ 为复数的辐角。根据其定义，有以下性质。 \\omega^{k}_{n}=e^{ i\\frac{2\\pi k}{n}}=\\cos {\\frac{2\\pi k}{n}}+i\\sin{\\frac{2\\pi k}{n}} \\omega_{2n}^{2k}=\\omega_{n}^{k} \\omega_{n}^{k}=-\\omega_{n}^{k+\\frac{n}{2}}我们已经确定了选那些数了，剩下的只剩带入求出该点的函数值！ 快速傅里叶变换我们如何快速求出他们 $\\omega{n}^{0},\\omega{n}^{1}\\cdots \\omega_{n}^{n-1}$ 的函数值？ f(x)=a_0+a_1x+a_2x^2+\\cdots +a_{n-1}x^{n-1},\\ \\ (x=\\omega_{n}^{k})按次数奇偶划分。 f(x)=(a_0+a_2x^2+a_4x^4+\\cdots+a_{n-2}x^{n-2})+(a_1x+a_3x^3+a_5x^5+\\cdots+a_{n-1}x^{n-1}),\\ \\ (x=\\omega_{n}^{k})划分成两个多项式。 f(x)=f_1(x^2)+xf_2(x^2),\\ \\ (x=\\omega_{n}^{k})发现： f(\\omega_{n}^{k})=f_1(\\omega_{n}^{2k})+\\omega_{n}^{k}f_2(\\omega_{n}^{2k})\\\\ 而f(\\omega_{n}^{k+\\frac{n}{2}})=f_1((-\\omega_{n}^{k})^2)-\\omega_{n}^{k}f_2((-\\omega_{n}^{k})^2)\\\\\\Leftrightarrow\\\\ f(\\omega_{n}^{k+\\frac{n}{2}})=f_1(\\omega_{n}^{2k})-\\omega_{n}^{k}f_2(\\omega_{n}^{2k})发现什么了吗？ 在 $\\omega{n}^{k}$ 和 $\\omega{n}^{k+\\frac{n}{2}}$ 的函数值，只差个负号。 所以我们可以只求出\\ \\ [0,\\frac{n}{2})的函数值就可以了。而我们每次这么操作时所需求解的区间就会折半，分治的思想。所以快速傅里叶复杂度保证在 $O(n\\log n)$ 了。 逆·快速傅里叶变换我们引进范德蒙德矩阵 \\left [ \\begin{matrix} 1 & x_0 & x_0^2 & \\cdots & x_0^{n-1} \\\\ 1 & x_1 & x_1^2 & \\cdots & x_1^{n-1} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ 1 & x_{n-1} & x_{n-1}^2 & \\cdots & x^{n-1}_{n-1} \\end{matrix} \\right] \\left [ \\begin{matrix} a_0 \\\\ a_1 \\\\ \\vdots\\\\ a_{n-1} \\end{matrix} \\right] = \\left [ \\begin{matrix} y_0 \\\\ y_1 \\\\ \\vdots\\\\ y_{n-1} \\end{matrix} \\right]这里的 $(xi,y_i)$ 即为点值表达。$a_i$ 为系数表达。我们记录 $V=\\left [\\begin{matrix}1 &amp; x_0 &amp; x_0^2 &amp; \\cdots &amp; x_0^{n-1} \\1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^{n-1} \\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\1 &amp; x{n-1} &amp; x{n-1}^2 &amp; \\cdots &amp; x^{n-1}{n-1}\\end{matrix}\\right]$在得知 $(x_i,y_i)$ 后我们只要算出 $V$ 的逆矩阵 $V^{-1}$ \\left [ \\begin{matrix} a_0 \\\\ a_1 \\\\ \\vdots\\\\ a_{n-1} \\end{matrix} \\right] = V^{-1} \\left [ \\begin{matrix} y_0 \\\\ y_1 \\\\ \\vdots\\\\ y_{n-1} \\end{matrix} \\right]好了，现在大力求逆矩阵就完了，所以我们开始高斯消元。ちょっとまって这尼玛不还是 $O(n^3)$?哦，我们突然发现（真的是发现）好像$V^{-1}{i\\ ,\\ j}=\\dfrac{\\omega {n}^{-ij}}{n}$ 你丫不是扯淡？ 证明P=V\\times V^{-1}\\ , P_{\\ i,\\ j}=\\sum _{k=0}^{n-1}\\frac{\\omega_{n}^{ki}\\times\\omega _{n}^{-jk}}{n}=\\sum _{k=0}^{n-1}\\frac{\\omega_{n}^{k(i-j)}}{n}发现$\\omega_{n}^{k(i-j)}$为等比数列当 $i\\neq j$ 时 原式=\\dfrac{1-w_{n}^{(i-j)n}}{1-\\omega_{n}^{i-j}}\\\\ 根据定义,\\omega_{n}^{(i-j)n}=(\\omega_{n}^{n})^{(i-j)}=1\\\\原式=0当 $i=j$ 时，原式 $=\\dfrac{n\\times \\omega_{n}^{0}}{n}=1$综上：得出 $P$ 为 $n$ 阶单位阵。根据逆矩阵定义 V^{-1}_{i\\ ,\\ j}=\\dfrac{\\omega _{n}^{-ij}}{n}这时我们只要在 $FFT$ 的过程中记录一个 $flag$ 在系数上$×-1$ 即可 void fft(Complex* a,int len,int f) { if(len==1) return; Complex a0[len/2],a1[len/2]; for(int i=0;i&lt;len;i++,i++) { a0[i/2]=a[i]; a1[i/2]=a[i+1]; } fft(a0,len/2,f); fft(a1,len/2,f); Complex wn(cos(f*2.0*pie/len),sin(f*2.0*pie/len)); Complex w(1,0); for(int i=0;i&lt;(len/2);i++) { a[i]=a0[i]+w*a1[i]; a[i+len/2]=a0[i]-w*a1[i]; w=w*wn; } } 还没完！$FFT$还没完，我们还要减小常数 1.小trickw*a1[i] 被算了两遍，没意义，所以 for(int i=0;i&lt;(len/2);i++) { Complex t=w*a1[i]; a[i]=a0[i]+t; a[i+len/2]=a0[i]-t; w=w*wn; } 说实话，仅仅这么改屁用没有。 2.我不用递归啦观察最后得到的数列： 观察化成二进制后正好反转了。最后的数列我们得到了。得到递推式： for(int i=0;i&lt;=lim;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1)); 然后从底层向上迭代。具体如下： const double p=acos(-1.0); inline void fft(Complex *a,int f) { for(int i=0;i&lt;lim;i++) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(int mid=1;mid&lt;lim;mid=mid&lt;&lt;1) { Complex wn(cos(1.0*p/mid),f*sin(1.0*p/mid)); for(int r=mid&lt;&lt;1,j=0;j&lt;lim;j+=r) { Complex w(1.0,0.0); for(int k=0;k&lt;mid;k++,w=w*wn) { Complex x=a[k+j],y=w*a[k+j+mid]; a[k+j]=x+y; a[k+j+mid]=x-y; } } } } $FFT$ 到此结束了。 $NTT$由于$FFT$ 炸精还慢，在模数特别时，$NTT$诞生了。 阶在$\\bmod\\ m$ 意义下，当 $(m,a)=1$ 时，使得 $a^r\\equiv 1 \\pmod m$ 的最小的 $r$ ，叫做 $a$ 关于 $m$ 的阶。记为 $\\delta_{n}(a)=r$ 。性质： 若 $(a,m)=1$,且 $a^n=1\\pmod m$,则 $\\delta_{m}(a)\\mid n$。 $\\delta_{m}(a)\\mid \\varphi(m)$。 原根若 $\\delta_{m}(a)=\\varphi(m)$ 则称 $a$ 是 $\\bmod\\ m$的一个原根。性质： 原根存在 $\\Leftrightarrow$ $m=2,4,p^e,2p^e$。 $m$ 有 $\\varphi(\\varphi(m))$ 个原根。 设 $g$ 为 $m$ 的一个原根，那么所有的原根为$g,g^2,g^3,\\ \\cdots \\ ,g^{\\varphi(i)}$。 发现有些性质和单位根相同，所以我们就使用原根代替单位根，实现快速数论卷积。实现与 $FFT$ 类似。 $MTT$我们的 $NTT$ 十分依赖模数，这使 $NTT$ 很鸡肋。 理论基础（雾（一般认为,两个FFT跑得比三个NTT稍微快一点。 有一种方法是将非 $NTT$ 模数拆成 $3$ 个原根模数，最后 $Crt$ 合并。但是这是九次 $NTT$ 慢死你。。。 根据command_block大佬的博客,这里提供一种五次 $FFT$ 的思路。首先是拆系数我们将 $f$ 拆成 $f=a_1\\times d + b_1,d=2^{15}$；$g=a_2\\times d + b_2,d=2^{15}$$f\\times g=a_1\\times a_2\\times d^2+(a_1\\times b_2+a_2\\times b_1)\\times d+b_1\\times b_2$emmm 四次 $DFT$，三次 $IDFT$，相当于 $7$次$FFT$ 慢死了。。ちょっとまって我们看：这种结构让我们想到了虚数乘法时的样子。我们设 $A_1$ 代表 $a_1$,$B_1$ 代表 $b_1$,$A_2$ 代表 $a_2$,$B_2$ 代表 $b_2$。设复多项式 $F=A_1+iA_2$ , $G=B_1+iB_2$$P_1=F\\times G=(A_1\\times B_1-A_2\\times B_2)+i(A_1\\times B_2+A_2\\times B_1)$再设 $H=A_1-iA_2$$P_2=H\\times G=(A_1\\times B_1+A_2\\times B_2)+i(A_1\\times B_2-A_2\\times B_1)$那么 $P_1+P_2=2(A_1\\times B_1+iA_1\\times B_2)$$A_1\\times B_1=Re(P_1+P_2)$ , $A_1\\times B_2=Im(P_1+P_2)$所以现在可以将$A_1\\times A_2,A_1\\times B_2,A_2\\times B_1,B_1\\times B_2$所以将 $F,G,H$ 转为点值表达花费 $3$ 次 $FFT$。$P_1,P_2$ 转回系数表达花费 $2$ 次 $FFT$。总记 $5$ 次 $FFT$$5FFT","categories":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"/tags/多项式/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"/categories/笔记/"}]},{"title":"第二类斯特林数·行","slug":"第二类斯特林数·行","date":"2020-04-07T02:20:10.000Z","updated":"2020-11-24T08:30:45.100Z","comments":true,"path":"2020/04/07/第二类斯特林数·行/","link":"","permalink":"/2020/04/07/第二类斯特林数·行/","excerpt":"","text":"什么是斯特林数? 第二类斯特林数我们定义第二类斯特林数 $\\begin{Bmatrix} n \\m \\end{Bmatrix}$ 表示把 $n$ 个不同元素划分成 $m$ 个相同的集合中的方案数。又名整数的无序分拆数，也可以表示为 $S(n,m)=\\begin{Bmatrix} n \\m \\end{Bmatrix}$。第二类斯特林数有2个重要性质: $\\begin{Bmatrix} n \\m \\end{Bmatrix}$ $=$ $\\begin{Bmatrix} n-1 \\m-1 \\end{Bmatrix}+m\\times \\begin{Bmatrix} n-1 \\m \\end{Bmatrix}$。 证明：设原集合为 $\\begin{Bmatrix}a_1,a_2\\cdots a_n\\end{Bmatrix}$ 我们将原始状态分为两种情况。 分别:$\\begin{Bmatrix}a_n\\end{Bmatrix}$ 做为独立的集合，此时答案为 $\\begin{Bmatrix} n-1 \\m-1 \\end{Bmatrix}$； 另一种情况则是 $\\begin{Bmatrix}a_n\\end{Bmatrix}$ 被插入了一个非空集合，因为有 $m$ 种选择，答案显然为 $m\\times \\begin{Bmatrix} n-1 \\m \\end{Bmatrix}$。 $m^n=\\displaystyle \\sum _{i=1}^{m} \\begin{Bmatrix}n\\i\\end{Bmatrix} \\times i! \\times \\begin{pmatrix}m\\i\\end{pmatrix}$。 这个可以这么理解：左面为将 $n$ 个数随意放在 $m$ 个集合中的方案数，可以存在空集； 而右面为枚举非空集合个数 $i$ 后求解该情况的答案，左面显然等于右面。 化简：由二项式反演 f(n) = \\sum_{i = 0}^{n} \\begin{pmatrix}n\\\\i\\end{pmatrix}g(i) \\Leftrightarrow g(n) = \\sum_{i = 0}^{n} (-1)^{n-i} \\begin{pmatrix}n\\\\i\\end{pmatrix}f(i)\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\sum\\limits _{i=1}^{m}\\frac{(-1)^{m-i}}{(m-i)!}\\times \\frac{m!}{i!}这是一个卷积形式，使用 ntt 即可","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"/tags/多项式/"},{"name":"学习","slug":"学习","permalink":"/tags/学习/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"RE:从零开始自闭的组合数学选讲","slug":"组合数学选讲","date":"2020-03-20T03:20:11.000Z","updated":"2020-11-24T08:30:45.100Z","comments":true,"path":"2020/03/20/组合数学选讲/","link":"","permalink":"/2020/03/20/组合数学选讲/","excerpt":"","text":"或许是我讲的最详细的一次吧。 前置姿势一大堆呀，挑主要的整理一些 基本概念，若$a\\times b \\equiv 1\\pmod p$ 则称$b$为$a\\pmod p$ 意义下的逆元，记作$a^{-1}$ 逆元存在定理，存在$a$在$\\pmod p$意义下的逆元$\\iff (a,p)=1$ 逆元性质，满足几乎所有分式性质，例如在$\\pmod p$意义下$a^{-1}\\times b^{-1}\\equiv(a\\times b)^{-1}\\pmod p$,$a\\times a^{-1}\\equiv 1\\pmod p$ 线性求逆元$i^{-1}\\equiv (p-p/i) \\times(p\\% i)^{-1}\\pmod p$ why?证明：设$p=a\\times i+b$ ($0\\leq$ $b&lt; i$)$a\\times i+b=p$$a\\times i+b\\equiv 0 \\pmod p$$-a\\times i\\equiv b \\pmod p$$-a\\times b^{-1}\\equiv i^{-1} \\pmod p$$i^{-1} \\equiv (p-a)\\times b^{-1} \\pmod p$也就是$(p\\% i)^{-1}\\pmod p$$Q.E.D$ 组合数定义$C^{m}{n}=\\frac{n!}{m!\\times (n-m)!}$补充定义，若$m&gt;n$时$C^{m}{n}=0$ 组合数的一堆性质$C{n}^{m}=C{n}^{n-m}$, $C{n}^{m}=C{n-1}^{m-1}+C_{n-1}^{m}$ 二项式定理$(1+x)^k=\\sum^{k}{i=0}C{k}^{i}x^i$ 卢卡斯定理，若p为质数$C{n}^{m}\\equiv C{n\\%p}^{m\\%p}\\times C{n/p}^{m/p}\\pmod p$引理：若$p$为质数$(1+x)^p\\equiv 1+x^p \\pmod p$引理证明：因为p为质数，所以当$2\\leq$ $k&lt; n$时$p\\mid C{p}^{k}$所以引理成立设$n=a\\times p+b,m=c\\times p+d$($0\\leq$ $b&lt; p$ , $0\\leq$ $d&lt; p$)$(1+x)^n=\\sum {i=0}^{n}C{n}^{i}\\times x^i$$(1+x)^n=(1+x)^{a\\times p+b}=((1+x)^p)^a\\times (1+x)^b\\equiv (1+x^p)^a\\times (1+x)^b\\equiv\\sum{i=0}^{a}C{a}^{i}x^{p\\times i}\\times\\sum{i=0}^{b}C{b}^{i}x^i \\pmod p$而$C{n}^{m}$代表的是$x^m$的系数，我们发现只能是第一个式子中$C{a}^{c}\\times x^{p\\times c}$第二个式子中的$C{b}^{d}\\times x^d$故系数为$C{a}^{c}\\times C{b}^{d}=C{n}^{m}$也就是说$C{n}^{m}=C{n\\%p}^{m\\%p}\\times C_{n/p}^{m/p}$ $Ex lucas$:不保证$p$是质数，求$C{n}^{m}\\%p$可以将$p$分成质数次幂$p=\\prod{i=1}pi^{\\alpha_i}$，我们似乎可以合并但不幸的是，我 TM并未保证$\\forall i,\\alpha_i=1$所以还不是质数，无法做。我们只能换而求$C{n}^{m}\\%pi^{\\alpha_i}$怎么办呢？发现$a$对$p$有逆元的充要条件为$gcd(a,p)=1$$\\displaystyle C{n}^{m}\\%P^{k}=\\displaystyle\\frac {\\displaystyle\\frac {n!}{P^{x}}}{\\displaystyle\\frac {m!}{P^{y}}\\displaystyle\\frac {(n-m)!}{P^{z}}}P^{x-y-z}\\bmod{P^k}$记$f(n)=\\frac {n!}{P^{x}}$$f(n)=f(\\lfloor\\frac{n}{P}\\rfloor)\\times(\\displaystyle\\prod{i=1,P\\displaystyle\\nmid i}^{P^k}i)^{\\displaystyle\\lfloor\\frac{n}{P^k}\\rfloor}\\times \\displaystyle\\prod{i=\\displaystyle\\lfloor\\frac{n}{P^k}\\rfloor\\times P^k,P\\displaystyle\\nmid i}^{n}i$ 然后怎么求其中的$x,y,z$什么的呢用$g(n)$代表$n!$里面有多少个$P$的因子$g(n)=\\lfloor \\frac nP\\rfloor+g(\\lfloor \\frac nP\\rfloor)$例题参考洛谷P4720 卡特兰数 $Cat{0}=1,Cat{1}=1,Cat{n}=\\sum{i=0}^{n-1}Cat{i}\\times Cat{n-i-1}=\\frac{C^{n}{2\\times n}}{n+1}=C^{n}{2n}-C_{n-1}^{2n}$ …待更 例题部分 例一计算系数根据二项式定理答案为$C_{k}^{n}\\times a^n\\times b^m$ 实现方法：预处理阶乘，及其逆元 inline void ginv() { inv[0]=1,inv[1]=1; finv[0]=f[0]=1; for(int i=2;i&lt;=p+100;i++) inv[i]=(p-p/i)*inv[p%i]%p; for(int i=1;i&lt;=p+100;i++) f[i]=f[i-1]*i%p,finv[i]=finv[i-1]*inv[i]%p; } inline int comb(int n,int m) { if(n&gt;m) return 0; return f[m]*finv[n]%p*finv[m-n]%p; } inline int lucas(int n,int m) { if(n&gt;m) return 0; return lucas(n/p,m/p)*comb(n%p,m%p)%p; } inline void work() { read(a),read(b),read(k),read(n),read(m); ginv(); printf(&quot;%lld\\n&quot;,qpow(a,n,p)*qpow(b,m,p)%p*lucas(n,k)%p); } 例二2^k进制数首先考虑$2^k$进制的一位相当于2进制的$k$位那么假如$k\\mid r$,我们可以假设成是有$\\frac{r}{k}$个$2^k$进制数，显然的，由于$2^k$有$2^k$个基本数码所以我们每次在这$2^k$中随便选$\\frac{r}{k}$个就行，然后给他排个序就行了。显然我们可以枚举位数，$i$答案即为$C_{2^k-1}^{i}$ 总的答案即为$\\displaystyle \\sum {i=0}^{r/k}C{2^k-1}^{i}$ 我们在考虑$k\\nmid r$时，我们考虑的只需要考虑$\\lfloor \\frac{r}{k}\\rfloor+1$位的情况就行枚举第一位的数值$1-(2^{r\\ mod\\ k}-1)$此时答案为$\\displaystyle \\sum{i=1}^{2^{r\\ mod\\ k}-1}C^{i}{2^k-1-i}$ 最终答案就为$\\displaystyle \\sum {i=0}^{r/k}C{2^k-1}^{i}+\\displaystyle \\sum{i=1}^{2^{r\\ mod\\ k}-1}C^{i}{2^k-1-i}$ 注意这道题需要高精 例三 组合本题同例一模板题 例四 古代猪文题意实在不好懂。。。大体就是让你求$s=\\displaystyle \\sum {k\\mid n}C{n}^{k}$然后再求$G^s\\pmod p,p$为质数由费马小定理$G^s\\equiv G^{s\\%(p-1)}\\pmod p$也就是要求$\\displaystyle \\sum {k\\mid n}C{n}^{k}\\%(p-1)$然后你就自闭了，因为(p-1)不是质数，没法求逆元。GG 本题无解所以我们想一下怎么yy，我们将$q=p-1$分解因数$q=\\sum_{i=1}p_i^{\\alpha_i}$后面过程极度舒适因为$q=p-1=999911659=2\\times3\\times4679\\times35617$只需每个模数求一般，用$crt$合并就$ok$了 例五 Bullcow我们考虑一个基本题，当这题没有k的限制，我们考虑总共有$m$只牛，$n$的杜牛，考虑插板在$(m-n)$个牛中找$n$个地方隔开所以答案为$C{m-n}^{n}$回到此题当确定了$i$个杜牛时，其中任意两个中有的牝牛的个数已确定了。所以我们考虑假设此时只有$m-(i-1)\\times k$牝牛所以答案为$C{m-(i-1)\\times k}^{i}$最终答案为$\\displaystyle \\sum {i=0}^{\\frac{m}{k}+1}C{m-(i-1)\\times k}^{i}$暴力硬跑就行 例六 方程的解数本题我也不知道为什么是组合数学$Meet\\ in\\ the\\ middle$折半搜索具体操作可以，枚举每一个$xi$的值，但肯定是不行的我们考虑优化。我们先考虑$i\\in {1,2,…,\\lfloor n/2\\rfloor},x_i$的取值，求出函数值,保存函数值的个数$num_i$然后枚举$i\\in {\\lfloor n/2\\rfloor+1,\\lfloor n/2\\rfloor+2,…,n},x_i$的取值，求出函数值,保存函数值的个数$num_i$，假如两组值有互为相反数的$x,-x$,答案应加上$num_x\\times num{-x}$完事了，可以用双指针数组，哈希表，map等实现。 例七 车的放置我最讨厌明明可以数学方法切，还要$dp$的。。。这题可以不$dp$ 引理:假如原图是个长方形 我们设长$n$,宽$m$,$k$个车则答案为$f(n,m,k)=\\frac{1}{k}\\times\\displaystyle \\sum_{i=0}^{k-1}(n-i)\\times(m-i)$ 我们将一个拐图分成两个长方形图 然后枚举任意一个长方形里的车的个数，假设右面矮的那个有$i$个车，则左面有$k-i$个车。因为右面一定对左面有影响所以右面答案:$f(c,d,i)$左面答案:$f(a,b+d-i,k-i)$很好理解吧。。。 例八 数三角形首先还是一个引理 我们可以发现从$(0,0)$原点到$(x,y)$点的线段经过了$gcd(x,y)+1$个整点(算$(0,0),(x,y)$) 我们首先不考虑三点共线情况答案是什么？当然是 $C_{n\\times m}^{3}$ 其次我们考虑平的三点共线答案是 $C{n\\times m}^{3}-n\\times C{m}^{3}-m\\times C_{n}^{3}$ 最终我们考虑斜着的三点共线好了，终于到正题了我们都知道一个区域中的三角形一定可以平移到该区域原点，如图。所以我们假如他可以三点共线，那么必可以平移到原点，此时我们只要算出整个区域内有多少个这样的三点共线（意思为平移后相同）然后在算出最远点到原点上有几个整数点$-2$（一个是该点，一个是原点），最后刚才两数一乘，答案减去就行了第一个，有多少个这样的三点共线我们发现，假设区域是$(n,m)$,点是$(x,y)$,一共就有$(n-x+1)\\times(m-y+1)$个第二个，引理说过应为$gcd(x,y)-1$部分代码 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) ans-=2*(n-i+1)*(m-j+1)*((gcd(i,j)-1)); } 为什么有个2。。。因为 每一个黑色对应一个红色我在这以前自己做的时候卡了好久。。 例九 combination同例一 例十 序列统计假如我们已经确定了序列长$i$那么此时我们求的$ai$单调不减的种类数。这不好求，我们转化为求$b_i=a_i+i$单调增的种类数所以进一步转换为求在$[L-1,(R+i)]$中选$i$个单调不减的数列我们类似前面的先随便选，你给他排序的想法，此时答案为$C{R+i-L}^{i}$总的答案就为$\\displaystyle \\sum {i=1}^{n}C{R+i-L}^{R-L}$怎么求? 这里给出一种几何$yy$做法 我们把杨辉三角画出，每个点的值均为其左上，右上的点的权值和。图中红色部分题目所求类似于图中紫色部分，假如我们要求紫色的和，我们先加上一个$F1=C{x}^{0}=1$，此时我们发现可以连锁反应，最后答案积累到点$D2$上而我们知道$M_1$是$C{R-L+n}^{R-L}$,不难发现$D2$是$C{R-L+n+1}^{R-L+1}$最后答案即为$C_{R-L+n+1}^{R-L+1}-1$(别忘了最初先加上的1) 例十二 超能粒子炮题目大意求$\\displaystyle \\sum{i=0}^{k}C{n}^{i}\\%p,p=2333$设$f(n,k)=\\sum{i=0}^{k}C{n}^{i}\\%p$由于模数小，首先$lucas$ 一波$f(n,k)=\\sum{i=0}^{k}C{n\\%p}^{i\\%p}\\times C{\\lfloor n/p\\rfloor}^{\\lfloor i/p\\rfloor}\\%p$看到了$i/p$ 我们，再次整除分块一波，就是将$i/p$相同的$i$分在一块里我们得到原式为$f(n,k)=\\displaystyle\\sum{t=0}^{\\lfloor k/p\\rfloor-1}\\sum{i=0}^{p-1}C^{i}{n\\%p}\\times C{n/p}^{t}+\\sum{i=0}^{k\\%p}C{\\lfloor n/p\\rfloor}^{\\lfloor k/p\\rfloor}\\times C{n\\%p}^{i}$整理一下$f(n,k)=\\displaystyle\\sum{t=0}^{\\lfloor k/p\\rfloor-1}C{\\lfloor n/p\\rfloor}^{t}\\times \\sum{i=0}^{p-1}C^{i}{n\\%p}+C{\\lfloor n/p\\rfloor}^{\\lfloor k/p\\rfloor}\\times\\sum{i=0}^{k\\%p} C{n\\%p}^{i}$设$g(n,k)=\\displaystyle\\sum{i=0}^{k}C{n}^{i}$现在进行最后一步化简$f(n,k)=f(\\lfloor n/p\\rfloor,\\lfloor k/p\\rfloor)\\times g(n\\%p,p-1)+C{\\lfloor n/p\\rfloor}^{\\lfloor k/p\\rfloor}\\times g(n\\%p,k\\%p)$怎么求$g(i,j)?$，和$C_{i}^{j}$一起$O(n^2)$预处理直接求$f(n,k)$直接递归求 例十三 礼物这题的式子很好想，直接乘法原理记$f(x)=\\displaystyle \\sum{i=1}^{x}w_i$$\\displaystyle\\prod {i=1}^{m} C^{wi}{n-f(i-1)}$你慌了，因为这个式子似乎无法化简了。但幸好$m \\leq 5$$\\times 10^5,O(m)$硬跑就行不妙的是，因为模数不为质数，你无法预处理阶乘的逆元但幸好你会$exlucas$直接就切了。。。 例十四 网格当不限制那条斜线时，我们答案就为$C_{n+m}^{n}$意思就为我们一共有$n+m$步，每一步都可能向上，或向右，我们选出有那几步向有，这个走的方法就确定了但是有限制。。。我们构造出所到点的关于那条斜线的对称点，然后，规定假如你第一次碰斜线，那么以后你假如向上，你就必须改为向左，反之亦然。不难证明到对称点的方式与到原终点且经过斜线的方法是一样的，我们只需求出到原终点方法数$-$到对称点的方法数就行了。完了。其实卡特兰数也可以使用这种类似方法给出大体证明，但在另一侧还需要几步生成函数，这里不讲了。 例十五 有趣的数列比较好的一道卡特兰数题$to$找规律的我也无法否定，但是假如题目特别猥琐给你了个带系数的答案，你还怎么找规律了呢?我们首先换一种角度想问题我们是在将$1-2n$按顺序填到数组里，而且每次只能从最靠前的没填过的奇数，偶数位填。我们必须保证任意时刻已填的奇数的个数一定要小于已填的偶数的个数。哦，这不可以类似我们刚才看的网格那题，该题要求的是向上的步数要在任意时刻小于向左的步数。。。这才是卡特兰数的模板。答案即为$Catn=\\frac{1}{n+1}\\times C{2n}^{n}$ 但不要忘了他的模数不保证是质数，所以，嘿嘿嘿。你可以用分解质因数的方法来$O(n\\log n)$强势x过去。就是类似 inline void ins(int x) { for(register int i=1;i&lt;=tot&amp;&amp;p[i]*p[i]&lt;=x;i++) if(x%p[i]==0) { while(x%p[i]==0) { if(!vis[x]&amp;&amp;x&lt;=n){vis[x]=1;return ;} x/=p[i],b[i]++; } } if(x&gt;1) b[mp[x]]++; } inline void del(int x) { for(register int i=1;i&lt;=tot&amp;&amp;p[i]*p[i]&lt;=x;i++) if(x%p[i]==0) while(x%p[i]==0) x/=p[i],b[i]--; if(x&gt;1) b[mp[x]]--; } ins就是乘上一个数。del就是除以一个数。显然是对的。。假如你会初一的单项式乘法，除法法则。。 例十六 树屋阶梯 引理:我们考虑假如是一个$k$阶树屋，那么要用长方形覆盖他，最少也要$k$个。 怎么证?数归：引理在$k=1$时成立假设引理在$k=n$时成立那么在$k=n+1$时答案即为$yk=\\min{i=1}^{n}{yi+y{n-i}}+1=i+n-i+1=n+1$故引理成立。那么我们就考虑切割树屋。此时，很明显，类似引理中的$yi$,$Ans_i=\\displaystyle\\sum{i=0}^{n}Ansi\\times Ans{n-i}$明显$Ansi$，就是卡特兰数由于$N\\leq500$，我们要高精度求出$Cat_N=C^{N}{2N}-C_{N-1}^{2N}$也是$O(n^2)$求出组合数 The end","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"/tags/组合数学/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"NOI online t2题解","slug":"NOI online t2题解","date":"2020-03-05T03:20:11.000Z","updated":"2020-11-24T08:30:45.097Z","comments":true,"path":"2020/03/05/NOI online t2题解/","link":"","permalink":"/2020/03/05/NOI online t2题解/","excerpt":"","text":"Noi online t2 爆零记题目链接记$ai$为原数组首先我们要知道一个性质就是记$c{ai}$ 为在第$i$位前且比第$i$大的数的个数每一次冒泡后,$c{ai}=max(c{a_i-1},0)$为什么？可以手玩试试看看题目给的伪代码 for i = 1 to n-1: if p[i] &gt; p[i + 1]: swap(p[i], p[i + 1]) 我们都知道冒泡排序每次是在将未排好序的数中最大数向后冒观察若对于第$i$位,$ai&gt;a{i+1}$则一次冒泡后变为$a{i+1},…$则$a{i+1}$后面所有没排好序的数$ak$其$c{ak}$都会$-1$当然$c{ak}=0$时就不管他了那我们的工作就是维护$c$这个数组更改直接分类讨论那求值就为$\\displaystyle \\sum{i=1}^{n}max(0,c{a_i}-k)$所以因为答案为零的是不会有贡献的所以我们化为$\\displaystyle \\sum {c{a_i}&gt;k} c{ai}-k$ $=$ $\\displaystyle \\sum {c{a_i}&gt;k} c{ai}-\\displaystyle \\sum {c_{a_i}&gt;k}k$然后就是树状数组的模板了$tips1:$ 注意k的大小,若k&gt;n就一定排好序了$tips1:$ 注意是树状数组,下标不为零 #include&lt;bits/stdc++.h&gt; #ifdef _WIN32 #include&lt;windows.h&gt; #endif using namespace std; template&lt;class T&gt;void read(T &amp;x){ x=0;int f=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;) {f|=(ch==&#39;-&#39;);ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();} x=f?-x:x; } #define int long long const int N=5e5; int n,m,t1[N],t2[N],num[N],a[N]; inline void insert(int x,int y1,int y2) { for(int i=x;i&lt;=n+1;i+=(i)&amp;(-i)) { t1[i]+=y1; t2[i]+=y2; } } inline int query1(int x) { int ans=0; for(int i=x;i&gt;0;i-=(i)&amp;(-i)) ans+=t1[i]; return ans; } inline int query2(int x) { int ans=0; for(int i=x;i&gt;0;i-=(i)&amp;(-i)) ans+=t2[i]; return ans; } int opt,k,x; signed main() { read(n),read(m); for(int i=1;i&lt;=n;i++) { read(a[i]); num[i]=query2(n)-query2(a[i]); insert(a[i],num[i],1); } memset(t1,0,sizeof(t1)); memset(t2,0,sizeof(t2)); for(int i=1;i&lt;=n;i++) insert(num[i] +1,num[i],1); for(int i=1;i&lt;=m;i++) { read(opt),read(x); if(opt==1) { // printf(&quot;%lld %lld\\n&quot;,num[x],num[x+1]); insert(num[x] +1,-num[x],-1); insert(num[x+1] +1,-num[x+1],-1); if(a[x]&lt;a[x+1]) { int vx=num[x],vx1=num[x+1]; insert(num[x+1] +1,num[x+1],1); insert(num[x]+1 +1,num[x]+1,1); num[x]=vx1; num[x+1]=vx+1; } else { int vx=num[x],vx1=num[x+1]; insert(num[x+1]-1 +1,num[x+1]-1,1); insert(num[x] +1,num[x],1); num[x]=vx1-1; num[x+1]=vx; } swap(a[x],a[x+1]); } else { if(x&gt;=n){puts(&quot;0&quot;);continue;} int frt=query1(n +1)-query1(x-1 +1); int mins=query2(n +1)-query2(x-1 +1); mins*=x; printf(&quot;%lld\\n&quot;,(frt-mins)&lt;0?0:frt-mins); } } #ifdef _WIN32 system(&quot;pause&quot;); #endif }","categories":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}],"tags":[],"keywords":[{"name":"题解","slug":"题解","permalink":"/categories/题解/"}]},{"title":"Protons知晓的定理","slug":"Protons知晓的定理","date":"2020-03-04T03:20:11.000Z","updated":"2020-11-24T08:30:45.098Z","comments":true,"path":"2020/03/04/Protons知晓的定理/","link":"","permalink":"/2020/03/04/Protons知晓的定理/","excerpt":"","text":"本文总结出一些蒟蒻曾经遇到的定理。 数论p.s.1下面没有特殊说明的变量一律认为是正整数 p.s.2 标$*$号的代表该定理结论正确但我不确定名字的定理 质数合数 唯一分解定律(貌似小学生都会)任意$n\\in N^{+}$都满足$n=\\displaystyle \\prod{i=1} p{i}^{\\alpha _{i}}$ 质数分布定理1~n中质数大约有$\\frac{n}{\\ln n}$ 约数个数定理$n\\in N^{+}$,$n=\\prod{i=1} p{i}^{\\alphai}$的约数个数为$\\prod{i=1} (\\alpha_{i}+1)$ 同余问题 同余定理*若$a\\equiv b (mod\\ p)$,则$a\\pm c\\equiv b\\pm c (mod\\ p)$,$a\\times c\\equiv b\\times c(mod\\ p)$同时若$a\\times c\\equiv b\\times c(mod\\ p)$则$a\\equiv b(mod\\ \\frac{p}{gcd(p,c)})$ 费马小定理若$p$是质数，$a^{p}\\equiv a(mod\\ p)$,推论当$p\\nmid a$时$a^{p-1}\\equiv 1(mod\\ p)$ 欧拉定理若$a\\bot m$,则$a^{\\varphi(m)}\\equiv 1(mod\\ p)$ 中国剩余定理给你$n$个关于$x$同余方程,第$i$的方程为$x\\equiv ai(mod\\ m_i)$那么若 对于任意 $i,j$ $1\\leq i$ $&lt;$ $j\\leq n$ ,$(i,j)=1$则定义$M=\\prod {i=1}^{n}mi$,$M_i=\\frac{M}{m_i},t_i\\equiv M_i^{-1}(mod\\ m_i)$,则原方程在$mod\\ M$意义下有唯一解$x \\equiv \\sum{i=1}^n a_i\\times t_i\\times M_i(mod\\ M)$ 扩展欧拉定理在 $b&gt;\\varphi(p)$ 时,$a^b\\equiv a^{b\\ mod \\ \\varphi(p)+\\varphi(p)}(mod\\ p)$ 逆元存在定理若$a^-1$ 在$mod\\ p$意义下存在，当且仅当$(a,p)=1$ 某不知名定理若$(a,p)=(b,p)=1$,$a^{x}\\equiv b^{x}(mod\\ p)$，且$a^{y}\\equiv b^{y}(mod\\ p)$ 那么$a^{(x,y)}\\equiv b^{(x,y)}(mod\\ p)$ 组合数问题 $n&gt;m时C^{n}{m}=0$,$n\\leq m时 C^{n}{m}=\\frac{m!}{n!\\times (m-n)!}$ 卢卡斯定理$C^{n}{m}\\equiv C^{n\\ mod\\ p}{m\\ mod\\ p}*C^{n/p}_{m/p}(mod\\ p)$ $C^{n}{m}=C^{n-1}{m-1}+C^{n-1}_{m}$ $n\\times C^{n}{m}=m\\times C^{n-1}{m-1}$ 二项式定理$(1+x)^n=\\displaystyle \\sum ^{n}{k=0} C{n}^{k}\\times x^k$Update 2020.3.7(NOI Online) $Update$每次冒泡排序，对于任意第i位，$C{i}$为第i位的逆序数个数，$C{i}=max(C_{i}-1,0)$ 这个坑太大了，我不想填了，考试中遇到好玩的也会咕咕咕的呀","categories":[{"name":"文章","slug":"文章","permalink":"/categories/文章/"}],"tags":[],"keywords":[{"name":"文章","slug":"文章","permalink":"/categories/文章/"}]}]}